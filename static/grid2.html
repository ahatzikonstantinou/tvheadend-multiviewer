<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>TV Mosaic Video Grid</title>
  <link rel="stylesheet" href="/static/css/grid.css">
  <link rel="stylesheet" href="/static/css/common.css">
</head>
<body>
  <header class="main-header">
    <div class="left-controls">
      <span>Global volume:</span>
      <input id="volumeSlider" type="range" min="0" max="1" step="0.01" value="0.0">
      <span id="volumeValue">0%</span>    
    </div>

    <!-- Navigation button --> 
     <button id="backToIndex" class="cog-btn">‚öôÔ∏è</button>
  </header>

  <div id="max-container">
    <div id="maxed-slot"></div>
    <div id="small-row-container">
      <div id="small-row"></div>
    </div>
  </div>

  <div id="grid"></div>

  <div id="epg-container">
    <h2>Electronic Program Guide</h2>
    <table id="epg-table">
      <thead>
        <tr>
          <th>Channel</th>
          <th>Start</th>
          <th>End</th>
          <th>Title</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>


  <script>
    let allVideos = [];
    let allMuteButtons = [];
    let wasMaxedVideoUnmuted = false;

    document.getElementById("backToIndex").addEventListener("click", () => {
      window.location.href = "/";
    });

    // this function is ncessary for smartphones, because a double click
    // on a smartphone browser is a small zoom in and never reaches the dom
    function addDoubleTapListener(element, callback) {
      let lastTouchTime = 0;

      // Mobile: double‚Äëtap via touchend
      element.addEventListener('touchend', (e) => {
        const now = Date.now();
        const delta = now - lastTouchTime;

        if (delta > 0 && delta < 300) {
          e.preventDefault();
          callback(e);
          lastTouchTime = 0; // reset
        } else {
          lastTouchTime = now;
        }
      }, { passive: false });

      // Desktop: normal dblclick
      element.addEventListener('dblclick', (e) => {
        e.preventDefault();
        callback(e);
      });
    }
    


    async function loadSettings() {
      const res = await fetch('/api/settings');
      return await res.json();
    }

    async function loadChannels(tvhUrl) {
      const res = await fetch('/api/channels', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ tvheadend_url: tvhUrl })
      });
      const j = await res.json();
      if (!j.ok) return [];
      return j.channels;
    }

    function findChannel(channels, uuid) {
      return channels.find(c => c.uuid === uuid);
    }

    function buildStreamURL(tvhUrl, channel) {
      return tvhUrl.replace(/\/$/, '') 
        + '/stream/channel/' + channel.uuid 
        // + '?profile=matroska';
        + '?profile=webtv-mp4';
    }

    function restartVideo(video, streamUrl) {
      video.pause();
      video.removeAttribute('src');
      video.load();
      video.src = streamUrl;
      video.play().catch(() => {});
    }

    function attachStreamMonitor(video, streamUrl, container) {
      let lastFrameTime = Date.now();
      let lastRestartTime = 0;
      const STARTUP_GRACE = 25000;   // 25 seconds
      const RESTART_COOLDOWN = 10000; // 10 seconds

      const markStalled = () => container.classList.add('video-stalled');
      const clearStalled = () => container.classList.remove('video-stalled');

      const safeRestart = () => {
        const now = Date.now();

        // Prevent restart loops
        if (now - lastRestartTime < RESTART_COOLDOWN) return;
        lastRestartTime = now;

        markStalled();

        video.pause();
        video.removeAttribute('src');
        video.load();

        setTimeout(() => {
          video.src = streamUrl;
          video.play().catch(() => {});
        }, 300);
      };

      // Update last frame time when video is actually progressing
      video.addEventListener('timeupdate', () => {
        lastFrameTime = Date.now();
        clearStalled();
      });

      // If video starts playing, clear stall state
      video.addEventListener('playing', clearStalled);

      // Error events ‚Üí restart
      video.addEventListener('error', safeRestart);
      video.addEventListener('stalled', safeRestart);
      video.addEventListener('abort', safeRestart);
      video.addEventListener('emptied', safeRestart);

      // Watchdog loop
      setInterval(() => {
        const now = Date.now();

        // Don‚Äôt judge too early
        if (now - lastRestartTime < STARTUP_GRACE) return;

        // If no frames for 10 seconds ‚Üí restart
        if (now - lastFrameTime > 10000) {
          safeRestart();
        }
      }, 2000);
    }

    function updateMuteButton(cell) {
      const video = cell.querySelector('video');
      const btn = cell.querySelector('.mute-btn');
      if (!video || !btn) return;

      if (video.muted) {
        btn.classList.add('muted');
        btn.textContent = 'Unmute';
      } else {
        btn.classList.remove('muted');
        btn.textContent = 'Mute';
      }
    }

    let maxedCell = null;

    function enableMaxMode(cell) {
      const grid = document.getElementById("grid");
      const maxContainer = document.getElementById("max-container");
      const maxSlot = document.getElementById("maxed-slot");
      const smallRow = document.getElementById("small-row");

      // Track audio state of previous maxed video
      if (maxedCell) {
        wasMaxedVideoUnmuted = !maxedCell.muted;
      } else {
        wasMaxedVideoUnmuted = false;
      }

      // Collect ALL cells
      const allCells = [
        ...grid.querySelectorAll(".cell"),
        ...smallRow.querySelectorAll(".cell"),
        ...maxSlot.querySelectorAll(".cell")
      ];

      // Sort by original index
      allCells.sort((a, b) =>
        Number(a.dataset.originalIndex) - Number(b.dataset.originalIndex)
      );

      // Clear containers
      maxSlot.innerHTML = "";
      smallRow.innerHTML = "";

      // Put clicked cell in max slot
      maxSlot.appendChild(cell);

      // Put all others in small row
      allCells.forEach(c => {
        if (c !== cell) smallRow.appendChild(c);
      });

      // Hide grid, show max container
      grid.classList.add("grid-hidden");
      maxContainer.style.display = "flex";

      // Auto-unmute logic
      if (wasMaxedVideoUnmuted) {
        // Mute all videos
        allVideos.forEach((v, idx) => {
          v.muted = true;
          allMuteButtons[idx].classList.remove('active');
          allMuteButtons[idx].textContent = 'Unmute';
        });

        // Unmute the new maxed video
        const video = cell.querySelector("video");
        const idx = allVideos.indexOf(video);
        if (idx !== -1) {
          video.muted = false;
          allMuteButtons[idx].classList.add('active');
          allMuteButtons[idx].textContent = 'Mute';
        }
      }

      cell.classList.add("maxed");
      maxedCell = cell;
      
      if (isMobile()) {
        // MOBILE: always unmute the maxed video, mute all others
        allVideos.forEach(v => {
          v.muted = true;
          const c = v.closest('.cell');
          if (c) updateMuteButton(c);
        });

        const video = cell.querySelector('video');
        if (video) {
          video.muted = false;
          updateMuteButton(cell);
        }

      } else {
        // DESKTOP: unmute maxed video only if any video is already unmuted
        const anyUnmuted = allVideos.some(v => !v.muted);

        if (anyUnmuted) {
          allVideos.forEach(v => {
            v.muted = true;
            const c = v.closest('.cell');
            if (c) updateMuteButton(c);
          });

          const video = cell.querySelector('video');
          if (video) {
            video.muted = false;
            updateMuteButton(cell);
          }
        }
      }

    }

    function disableMaxMode() {
      const grid = document.getElementById("grid");
      const maxContainer = document.getElementById("max-container");
      const smallRow = document.getElementById("small-row");
      const maxSlot = document.getElementById("maxed-slot");

      // Collect all cells
      const allCells = [
        ...smallRow.children,
        ...maxSlot.children
      ];

      // Sort by original index
      allCells.sort((a, b) =>
        Number(a.dataset.originalIndex) - Number(b.dataset.originalIndex)
      );

      // Restore in correct order
      allCells.forEach(c => grid.appendChild(c));

      // Hide max container, show grid
      maxContainer.style.display = "none";
      grid.classList.remove("grid-hidden");

      maxedCell.classList.remove("maxed");
      maxedCell = null;

      if (isMobile()) {
        if (document.fullscreenElement) {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen(); // iOS Safari
          }
        }
      }

    }

    function createCell(tvhUrl, channel, streamUrl, index) {
      const cellDiv = document.createElement('div');
      cellDiv.className = 'cell';

      // store original position and uuid
      cellDiv.dataset.originalIndex = index;
      cellDiv.dataset.uuid = channel.uuid;

      const videoWrapper = document.createElement('div');
      videoWrapper.className = 'video-wrapper';

      const video = document.createElement('video');
      video.autoplay = true;
      video.muted = true;          // start muted
      video.playsInline = true;
      video.src = streamUrl;
      attachStreamMonitor(video, streamUrl, cellDiv);

      videoWrapper.appendChild(video);
      cellDiv.appendChild(videoWrapper);

      const infoBar = document.createElement('div');
      infoBar.className = 'info-bar';

      const label = document.createElement('div');
      label.className = 'channel-label';
      label.textContent = (channel.number ? channel.number + ' ' : '') + channel.name;

      const muteBtn = document.createElement('button');
      muteBtn.className = 'mute-btn';
      muteBtn.textContent = 'Unmute';

      muteBtn.addEventListener('click', () => {
        handleMuteToggle(video, muteBtn, channel, tvhUrl);
      });

      const restartBtn = document.createElement('button');
      restartBtn.className = 'restart-btn';
      restartBtn.innerHTML = 'üîÑ';   // icon only
      restartBtn.title = 'Restart stream';

      restartBtn.addEventListener('click', () => {
        restartVideo(video, streamUrl);
      });

      infoBar.appendChild(label);
      infoBar.appendChild(muteBtn);
      infoBar.appendChild(restartBtn);
      cellDiv.appendChild(infoBar);

      allVideos.push(video);
      allMuteButtons.push(muteBtn);

      addDoubleTapListener(cellDiv, () => {
        // CASE 1: nothing maxed yet
        if (!maxedCell) {
          enableMaxMode(cellDiv);

          if (isMobile() && !inFullscreen()) {
            cellDiv.requestFullscreen?.();
            cellDiv.webkitRequestFullscreen?.();
          }
          return;
        }

        // CASE 2: tapping the already maxed video
        if (maxedCell === cellDiv) {
          if (isMobile() && inFullscreen()) {
            exitFs();
          } else {
            disableMaxMode();
          }
          return;
        }

        // CASE 3: switching maxed video
        enableMaxMode(cellDiv);
      });

      return cellDiv;
    }

    function handleMuteToggle(targetVideo, targetButton, channel, tvhUrl) {
      const isCurrentlyMuted = targetVideo.muted;

      if (isCurrentlyMuted) {
        // Mute all videos
        allVideos.forEach((v, idx) => {
          v.muted = true;
          allMuteButtons[idx].classList.remove('active');
          allMuteButtons[idx].textContent = 'Unmute';
        });

        // Activate this one
        targetVideo.muted = false;
        targetButton.classList.add('active');
        targetButton.textContent = 'Mute';        
      } else {
        // Muting this one
        targetVideo.muted = true;
        targetButton.classList.remove('active');
        targetButton.textContent = 'Unmute';
      }
    }

    function setupGlobalVolumeControl() {
      const slider = document.getElementById('volumeSlider');
      const valueLabel = document.getElementById('volumeValue');
      // const audio = document.getElementById('audioPlayer');

      // Load saved volume or default to 1.0
      const savedVolume = localStorage.getItem('mosaicAudioVolume');
      const initialVolume = savedVolume !== null ? parseFloat(savedVolume) : 1.0;

      slider.value = initialVolume;
      valueLabel.textContent = Math.round(initialVolume * 100) + '%';

      // // Apply stored volume to the audio element only
      // audio.volume = initialVolume;

      // Apply stored volume to ALL videos 
      allVideos.forEach(v => v.volume = initialVolume);

      const applyVolume = (val) => {
        // audio.volume = val;
        // Apply to all videos
        allVideos.forEach(v => v.volume = val);
        
        valueLabel.textContent = Math.round(val * 100) + '%';

        // Persist the value
        localStorage.setItem('mosaicAudioVolume', val);
      };

      slider.addEventListener('input', () => {
        const val = parseFloat(slider.value);
        applyVolume(val);
      });
    }      

    async function renderGrid() {
      const cfg = await loadSettings();
      const channels = await loadChannels(cfg.tvheadend_url);

      // set fixed number of columns from config
      document.documentElement.style.setProperty('--grid-cols', cfg.grid_cols);

      const container = document.getElementById('grid');
      container.innerHTML = '';
      allVideos = [];
      allMuteButtons = [];

      for (let r = 0; r < cfg.grid_rows; r++) {
        for (let c = 0; c < cfg.grid_cols; c++) {
          const index = r * cfg.grid_cols + c;

          const cellCfg = cfg.cells.find(x => x.row === r && x.col === c);

          if (cellCfg && cellCfg.channel_uuid) {
            const ch = findChannel(channels, cellCfg.channel_uuid);
            if (ch) {
              const streamUrl = buildStreamURL(cfg.tvheadend_url, ch);
              const cell = createCell(cfg.tvheadend_url, ch, streamUrl, index);
              container.appendChild(cell);
            } else {
              const emptyCell = document.createElement('div');
              emptyCell.className = 'cell empty-cell';
              emptyCell.textContent = 'Unknown channel';
              container.appendChild(emptyCell);
            }
          } else {
            const emptyCell = document.createElement('div');
            emptyCell.className = 'cell empty-cell';
            emptyCell.textContent = 'Empty';
            container.appendChild(emptyCell);
          }
        }
      }

      setupGlobalVolumeControl();
    }

    renderGrid();

    function isMobile() {
      return /Android|iPhone|iPad|iPod|Mobi/i.test(navigator.userAgent);
    }

    function applyMobileFullscreenFix() {
      if (!isMobile()) return;

      const fsEl = document.fullscreenElement || document.webkitFullscreenElement;
      if (!fsEl) return;

      const wrapper = fsEl.querySelector('.video-wrapper');
      // const video = fsEl.querySelector('video');

      const isPortrait = window.innerHeight > window.innerWidth;

      let w;

      if (isPortrait) {
        // Portrait: use full width
        w = window.innerWidth + 'px';
      } else {
        // Landscape: subtract your 96px offset
        w = (window.innerWidth - 96) + 'px';
      }

      fsEl.style.width = w;
      if (wrapper) wrapper.style.width = w;
    }

    // optional: update on orientation / resize while in fullscreen
    window.addEventListener('resize', () => {
      if (document.fullscreenElement) {
        applyMobileFullscreenFix();
      }
    });

    function inFullscreen() {
      return document.fullscreenElement || document.webkitFullscreenElement;
    }

    function exitFs() {
      if (document.exitFullscreen) document.exitFullscreen();
      else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
    }    

    function setupTapToExitFullscreen() {
      document.addEventListener('touchend', () => {
        if (document.fullscreenElement || document.webkitFullscreenElement) {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          }
        }
      });
    }

    setupTapToExitFullscreen();

    function setupFullscreenHeaderBehavior() {
      const header = document.querySelector('header');

      document.addEventListener('fullscreenchange', () => {
        if (document.fullscreenElement) {
          header.classList.add('hidden-in-fullscreen');
        } else {
          header.classList.remove('hidden-in-fullscreen');
        }
      });

      // iOS Safari fallback
      document.addEventListener('webkitfullscreenchange', () => {
        if (document.webkitFullscreenElement) {
          header.classList.add('hidden-in-fullscreen');
        } else {
          header.classList.remove('hidden-in-fullscreen');
        }
      });
    }    

    setupFullscreenHeaderBehavior();

    function setupFullscreenHandler() {
      const onFsChange = () => {
        const fsEl = document.fullscreenElement || document.webkitFullscreenElement;

        if (fsEl) {
          // ENTERING FULLSCREEN
          applyMobileFullscreenFix();
          return;
        }

        // EXITING FULLSCREEN
        const maxed = document.querySelector('.cell.maxed');
        if (maxed) {
          maxed.style.height = '';
          maxed.style.width = '';
          const wrapper = maxed.querySelector('.video-wrapper');
          // const video = maxed.querySelector('video');
          if (wrapper) {
            wrapper.style.height = '';
            wrapper.style.width = '';
          }
          // if (video) video.style.height = '';
        }

        if (maxedCell) {
          disableMaxMode();
        }
      };

      document.addEventListener('fullscreenchange', onFsChange);
      document.addEventListener('webkitfullscreenchange', onFsChange);
    }

    document.addEventListener('DOMContentLoaded', setupFullscreenHandler);


    //EPG
    let epgCache = [];
    let epgByChannel = {};

    async function refreshEPG() {
      const response = await fetch("/api/epg/all");
      const data = await response.json();

      if (data.status === "ok") {
        epgCache = data.programs;
        epgByChannel = groupByChannel(epgCache);
        console.log("EPG refreshed:", epgCache.length, "programs");
        renderEPGTable();
      } else {
        console.error("EPG refresh error:", data.message);
      }
    }

    refreshEPG().then(() => {
      refreshAllInfobars();
    });

    setInterval(refreshEPG, 5 * 60 * 1000);

    function groupByChannel(programs) {
      const map = {};
      programs.forEach(p => {
        if (!map[p.channelUuid]) {
          map[p.channelUuid] = [];
        }
        map[p.channelUuid].push(p);
      });
      return map;
    }

    function getCurrentProgram(channelUuid) {
      const now = Date.now() / 1000; // œÉŒµ seconds
      const programs = epgByChannel[channelUuid] || [];

      for (const p of programs) {
        if (p.start <= now && now <= p.stop) {
          return p;
        }
      }

      return null;
    }

    function refreshAllInfobars() {
      const cells = document.querySelectorAll(".cell");

      cells.forEach(cell => {
        const uuid = cell.dataset.uuid;
        if (!uuid) return;

        const current = getCurrentProgram(uuid);
        const label = cell.querySelector(".channel-label");

        if (current && label) {
          label.textContent = 
            (current.channelNumber ? current.channelNumber + ' ' : '') 
            + current.channelName + ' - '
            + (current.title || "");
        }
      });
    }

    setInterval(() => {
        refreshAllInfobars();
    }, 30 * 1000);

    function renderEPGTable() {
      const tbody = document.querySelector("#epg-table tbody");
      tbody.innerHTML = "";

      // 1. Collect UUIDs currently displayed in the grid
      const gridCells = document.querySelectorAll("#grid .cell");
      const gridUUIDs = Array.from(gridCells).map(c => c.dataset.uuid);

      // 2. Sort channels: first those in the grid, then alphabetical
      const sortedChannels = Object.keys(epgByChannel).sort((a, b) => {
        const inGridA = gridUUIDs.includes(a);
        const inGridB = gridUUIDs.includes(b);

        if (inGridA && !inGridB) return -1;
        if (!inGridA && inGridB) return 1;

        const nameA = epgByChannel[a][0]?.channelName || "";
        const nameB = epgByChannel[b][0]?.channelName || "";
        return nameA.localeCompare(nameB);
      });

      // 3. Build table rows
      sortedChannels.forEach(uuid => {
        const programs = epgByChannel[uuid];
        if (!programs || programs.length === 0) return;

        const channelName = programs[0].channelName;
        const rowspan = programs.length;

        programs.forEach((p, index) => {
          const tr = document.createElement("tr");

          // Format HH:MM only
          const startTime = p.start_str.split(" ")[1];
          const endTime = p.stop_str.split(" ")[1];
          
          if (index === 0) {
            // Channel name only on first row
            const tdChannel = document.createElement("td");
            tdChannel.textContent = channelName;
            tdChannel.rowSpan = rowspan;
            tr.appendChild(tdChannel);

            // thick border only between channels
            tr.classList.add("channel-start");
          }

          // Start time column
          const tdStart = document.createElement("td");
          tdStart.className = "start-col";
          tdStart.textContent = startTime;
          tr.appendChild(tdStart);

          // End time column
          const tdEnd = document.createElement("td");
          tdEnd.className = "end-col";
          tdEnd.textContent = endTime;
          tr.appendChild(tdEnd);

          // Title
          const tdTitle = document.createElement("td");
          tdTitle.textContent = p.title || "";
          tr.appendChild(tdTitle);

          // Description with <details>
          const tdDesc = document.createElement("td");
          const desc = p.summary || p.description || "";

          if( desc.length > 0) {
            tdDesc.innerHTML = `
              <details>
                <summary>${desc}</summary>              
              </details>
            `;
          }
          tr.appendChild(tdDesc);

          tbody.appendChild(tr);
        });
      });
    }


  </script>
</body>
</html>
