<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>TV Mosaic Video Grid</title>
  <style>
    :root {
      --grid-cols: 4; /* default, will be overridden by JS */
    }

    body {
      font-family: sans-serif;
      margin: 0;
      background: #111;
      color: #eee;
      display: flex;
      flex-direction: column;
      height: 100vh;
      touch-action: manipulation; 
    }

    header {
      padding: 8px 12px;
      background: #222;
      display: flex;
      align-items: center;
      gap: 10px;
      flex-shrink: 0;
    }

    header.hidden-in-fullscreen {
      display: none;
    }

    /* fullscreen tweeks*/
    html, body {
      height: 100%;
      margin: 0;
    }

    /* Fullscreen root */
    :fullscreen,
    :-webkit-full-screen {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    /* Hide all cells except the maxed one */
    :fullscreen .cell,
    :-webkit-full-screen .cell {
      display: none !important;
    }

    :fullscreen .cell.maxed,
    :-webkit-full-screen .cell.maxed {
      display: block; /*flex !important;*/
      /* flex-direction: column;
      width: 100vw;
      height: 100vh;
      overflow: hidden; */
      position: relative;
    }

    /* Video wrapper fills fullscreen */
    :fullscreen .cell.maxed .video-wrapper,
    :-webkit-full-screen .cell.maxed .video-wrapper {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      display: flex;
      justify-content: center; /* center horizontally */
      align-items: center; /* center vertically */
      /*position: absolute; 
      top: 0; 
      left: 0; 
      right: 0; 
      bottom: 0; /* full height */
    }

    /* Video fits exactly */
    :fullscreen .cell.maxed video,
    :-webkit-full-screen .cell.maxed video {
      width: 100vw; /* scale by width */
      height: auto;
      max-height: 100vh; /* never exceed screen height */
      object-fit: contain;
    }

    /* Hide small row */
    :fullscreen #small-row-container,
    :-webkit-full-screen #small-row-container {
      display: none !important;
    }

    :fullscreen .cell.maxed .info-bar,
    :-webkit-full-screen .cell.maxed .info-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      z-index: 10;
    }


    /*end of fullscreen tweeks*/
    
    header span {
      font-size: 14px;
    }

    #volumeSlider {
      width: 200px;
    }

    .fullscreen-btn { 
      margin-left: auto; /* push to the right */ 
      font-size: 20px; 
      padding: 4px 10px; 
      background: #333; 
      color: white; 
      border: none; 
      border-radius: 4px; 
    } 
    
    .fullscreen-btn:active { 
      background: #555; 
    }

    /* for flexibe grid*/
    #grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(clamp(250px, 32vw, 1200px), 1fr));
      gap: 6px;
      /* width: 100%; */
      /* height: 100%; */
      padding: 6px;
      box-sizing: border-box;
      align-content: start;
      flex: 1 1 auto;
    }

    .cell {
      position: relative;
      width: 100%;
      background: #000;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      touch-action: manipulation; /* or none, if you donâ€™t need native gestures */
    }

    .cell video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover; /* Î³ÎµÎ¼Î¯Î¶ÎµÎ¹ Ï„Î¿ 16:9 container */
    }

    .video-wrapper {
      position: relative;
      width: 100%;
      /* 16:9 aspect ratio */
      aspect-ratio: 16 / 9;
      background: #000;
      overflow: hidden;
      flex-shrink: 0;
    }

    video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      background: #000;
      z-index: 1;
    }

    .video-stalled {
      border: 3px solid red !important;
    }

    .info-bar {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 4px 6px;
      background: #222;
      font-size: 12px;
      box-sizing: border-box;
    }

    .channel-label {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      margin-right: 8px;
    }

    .mute-btn {
      padding: 2px 8px;
      font-size: 11px;
      cursor: pointer;
      border: 1px solid #555;
      background: #333;
      color: #eee;
      border-radius: 3px;
    }

    .mute-btn.active {
      background: #e91e63;
      border-color: #ff80ab;
    }

    .empty-cell {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 13px;
      color: #aaa;
    }

    .restart-btn {
      background: transparent;
      border: none;
      font-size: 20px;
      cursor: pointer;
      padding: 4px;
      opacity: 0.7;
    }

    .restart-btn:hover {
      opacity: 1;
    }

    /* Container that holds the maxed video + the row of small videos */
    #max-container {
      display: none;
      flex-direction: column;
      width: 100%;
      gap: 6px;
    }

    /* Maxed video wrapper */
    .maxed-video {
      width: 100%;
      aspect-ratio: 16 / 9;
      position: relative;
      overflow: hidden;
    }

    /* Row of small videos */
    #small-row {
      display: flex;
      flex-wrap: wrap;              /* allow wrapping when needed */
      gap: 6px;
      width: 100%;
      overflow: hidden;             /* no scrollbars */
    }

    #small-row .cell {
      flex: 1 1 clamp(140px, 18vw, 440px);
      /* 140px  â†’ never too tiny
        18vw   â†’ ideal size relative to viewport
        440px  â†’ as large as it can get*/
      position: relative;
      max-width: 440px;             /* ensures nice wrapping */
    }


    /* Hide grid when maxed mode is active */
    .grid-hidden {
      display: none !important;
    }


  </style>
</head>
<body>
  <header>
    <span>Global volume:</span>
    <input id="volumeSlider" type="range" min="0" max="1" step="0.01" value="0.0">
    <span id="volumeValue">0%</span>    
  </header>

  <div id="max-container">
    <div id="maxed-slot"></div>
    <div id="small-row-container">
      <div id="small-row"></div>
    </div>
  </div>

  <div id="grid"></div>


  <script>
    let allVideos = [];
    let allMuteButtons = [];
    let wasMaxedVideoUnmuted = false;

    // this function is ncessary for smartphones, because a double click
    // on a smartphone browser is a small zoom in and never reaches the dom
    function addDoubleTapListener(element, callback) {
      let lastTouchTime = 0;

      // Mobile: doubleâ€‘tap via touchend
      element.addEventListener('touchend', (e) => {
        const now = Date.now();
        const delta = now - lastTouchTime;

        if (delta > 0 && delta < 300) {
          e.preventDefault();
          callback(e);
          lastTouchTime = 0; // reset
        } else {
          lastTouchTime = now;
        }
      }, { passive: false });

      // Desktop: normal dblclick
      element.addEventListener('dblclick', (e) => {
        e.preventDefault();
        callback(e);
      });
    }
    


    async function loadSettings() {
      const res = await fetch('/api/settings');
      return await res.json();
    }

    async function loadChannels(tvhUrl) {
      const res = await fetch('/api/channels', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ tvheadend_url: tvhUrl })
      });
      const j = await res.json();
      if (!j.ok) return [];
      return j.channels;
    }

    function findChannel(channels, uuid) {
      return channels.find(c => c.uuid === uuid);
    }

    function buildStreamURL(tvhUrl, channel) {
      return tvhUrl.replace(/\/$/, '') 
        + '/stream/channel/' + channel.uuid 
        // + '?profile=matroska';
        + '?profile=webtv-mp4';
    }

    function restartVideo(video, streamUrl) {
      video.pause();
      video.removeAttribute('src');
      video.load();
      video.src = streamUrl;
      video.play().catch(() => {});
    }

    function attachStreamMonitor(video, streamUrl, container) {
      let lastFrameTime = Date.now();
      let lastRestartTime = 0;
      const STARTUP_GRACE = 25000;   // 25 seconds
      const RESTART_COOLDOWN = 10000; // 10 seconds

      const markStalled = () => container.classList.add('video-stalled');
      const clearStalled = () => container.classList.remove('video-stalled');

      const safeRestart = () => {
        const now = Date.now();

        // Prevent restart loops
        if (now - lastRestartTime < RESTART_COOLDOWN) return;
        lastRestartTime = now;

        markStalled();

        video.pause();
        video.removeAttribute('src');
        video.load();

        setTimeout(() => {
          video.src = streamUrl;
          video.play().catch(() => {});
        }, 300);
      };

      // Update last frame time when video is actually progressing
      video.addEventListener('timeupdate', () => {
        lastFrameTime = Date.now();
        clearStalled();
      });

      // If video starts playing, clear stall state
      video.addEventListener('playing', clearStalled);

      // Error events â†’ restart
      video.addEventListener('error', safeRestart);
      video.addEventListener('stalled', safeRestart);
      video.addEventListener('abort', safeRestart);
      video.addEventListener('emptied', safeRestart);

      // Watchdog loop
      setInterval(() => {
        const now = Date.now();

        // Donâ€™t judge too early
        if (now - lastRestartTime < STARTUP_GRACE) return;

        // If no frames for 10 seconds â†’ restart
        if (now - lastFrameTime > 10000) {
          safeRestart();
        }
      }, 2000);
    }

    function updateMuteButton(cell) {
      const video = cell.querySelector('video');
      const btn = cell.querySelector('.mute-btn');
      if (!video || !btn) return;

      if (video.muted) {
        btn.classList.add('muted');
        btn.textContent = 'Unmute';
      } else {
        btn.classList.remove('muted');
        btn.textContent = 'Mute';
      }
    }

    let maxedCell = null;

    function enableMaxMode(cell) {
      const grid = document.getElementById("grid");
      const maxContainer = document.getElementById("max-container");
      const maxSlot = document.getElementById("maxed-slot");
      const smallRow = document.getElementById("small-row");

      // Track audio state of previous maxed video
      if (maxedCell) {
        wasMaxedVideoUnmuted = !maxedCell.muted;
      } else {
        wasMaxedVideoUnmuted = false;
      }

      // Collect ALL cells
      const allCells = [
        ...grid.querySelectorAll(".cell"),
        ...smallRow.querySelectorAll(".cell"),
        ...maxSlot.querySelectorAll(".cell")
      ];

      // Sort by original index
      allCells.sort((a, b) =>
        Number(a.dataset.originalIndex) - Number(b.dataset.originalIndex)
      );

      // Clear containers
      maxSlot.innerHTML = "";
      smallRow.innerHTML = "";

      // Put clicked cell in max slot
      maxSlot.appendChild(cell);

      // Put all others in small row
      allCells.forEach(c => {
        if (c !== cell) smallRow.appendChild(c);
      });

      // Hide grid, show max container
      grid.classList.add("grid-hidden");
      maxContainer.style.display = "flex";

      // Auto-unmute logic
      if (wasMaxedVideoUnmuted) {
        // Mute all videos
        allVideos.forEach((v, idx) => {
          v.muted = true;
          allMuteButtons[idx].classList.remove('active');
          allMuteButtons[idx].textContent = 'Unmute';
        });

        // Unmute the new maxed video
        const video = cell.querySelector("video");
        const idx = allVideos.indexOf(video);
        if (idx !== -1) {
          video.muted = false;
          allMuteButtons[idx].classList.add('active');
          allMuteButtons[idx].textContent = 'Mute';
        }
      }

      cell.classList.add("maxed");
      maxedCell = cell;
      
      if (isMobile()) {
        // MOBILE: always unmute the maxed video, mute all others
        allVideos.forEach(v => {
          v.muted = true;
          const c = v.closest('.cell');
          if (c) updateMuteButton(c);
        });

        const video = cell.querySelector('video');
        if (video) {
          video.muted = false;
          updateMuteButton(cell);
        }

      } else {
        // DESKTOP: unmute maxed video only if any video is already unmuted
        const anyUnmuted = allVideos.some(v => !v.muted);

        if (anyUnmuted) {
          allVideos.forEach(v => {
            v.muted = true;
            const c = v.closest('.cell');
            if (c) updateMuteButton(c);
          });

          const video = cell.querySelector('video');
          if (video) {
            video.muted = false;
            updateMuteButton(cell);
          }
        }
      }

    }

    function disableMaxMode() {
      const grid = document.getElementById("grid");
      const maxContainer = document.getElementById("max-container");
      const smallRow = document.getElementById("small-row");
      const maxSlot = document.getElementById("maxed-slot");

      // Collect all cells
      const allCells = [
        ...smallRow.children,
        ...maxSlot.children
      ];

      // Sort by original index
      allCells.sort((a, b) =>
        Number(a.dataset.originalIndex) - Number(b.dataset.originalIndex)
      );

      // Restore in correct order
      allCells.forEach(c => grid.appendChild(c));

      // Hide max container, show grid
      maxContainer.style.display = "none";
      grid.classList.remove("grid-hidden");

      maxedCell.classList.remove("maxed");
      maxedCell = null;

      if (isMobile()) {
        if (document.fullscreenElement) {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen(); // iOS Safari
          }
        }
      }

    }

    function createCell(tvhUrl, channel, streamUrl, index) {
      const cellDiv = document.createElement('div');
      cellDiv.className = 'cell';

      // store original position
      cellDiv.dataset.originalIndex = index;

      const videoWrapper = document.createElement('div');
      videoWrapper.className = 'video-wrapper';

      const video = document.createElement('video');
      video.autoplay = true;
      video.muted = true;          // start muted
      video.playsInline = true;
      video.src = streamUrl;
      attachStreamMonitor(video, streamUrl, cellDiv);

      videoWrapper.appendChild(video);
      cellDiv.appendChild(videoWrapper);

      const infoBar = document.createElement('div');
      infoBar.className = 'info-bar';

      const label = document.createElement('div');
      label.className = 'channel-label';
      label.textContent = (channel.number ? channel.number + ' ' : '') + channel.name;

      const muteBtn = document.createElement('button');
      muteBtn.className = 'mute-btn';
      muteBtn.textContent = 'Unmute';

      muteBtn.addEventListener('click', () => {
        handleMuteToggle(video, muteBtn, channel, tvhUrl);
      });

      const restartBtn = document.createElement('button');
      restartBtn.className = 'restart-btn';
      restartBtn.innerHTML = 'ðŸ”„';   // icon only
      restartBtn.title = 'Restart stream';

      restartBtn.addEventListener('click', () => {
        restartVideo(video, streamUrl);
      });

      infoBar.appendChild(label);
      infoBar.appendChild(muteBtn);
      infoBar.appendChild(restartBtn);
      cellDiv.appendChild(infoBar);

      allVideos.push(video);
      allMuteButtons.push(muteBtn);

      addDoubleTapListener(cellDiv, () => {
        // CASE 1: nothing maxed yet
        if (!maxedCell) {
          enableMaxMode(cellDiv);

          if (isMobile() && !inFullscreen()) {
            cellDiv.requestFullscreen?.();
            cellDiv.webkitRequestFullscreen?.();
          }
          return;
        }

        // CASE 2: tapping the already maxed video
        if (maxedCell === cellDiv) {
          if (isMobile() && inFullscreen()) {
            exitFs();
          } else {
            disableMaxMode();
          }
          return;
        }

        // CASE 3: switching maxed video
        enableMaxMode(cellDiv);
      });

      return cellDiv;
    }

    function handleMuteToggle(targetVideo, targetButton, channel, tvhUrl) {
      const isCurrentlyMuted = targetVideo.muted;

      if (isCurrentlyMuted) {
        // Mute all videos
        allVideos.forEach((v, idx) => {
          v.muted = true;
          allMuteButtons[idx].classList.remove('active');
          allMuteButtons[idx].textContent = 'Unmute';
        });

        // Activate this one
        targetVideo.muted = false;
        targetButton.classList.add('active');
        targetButton.textContent = 'Mute';        
      } else {
        // Muting this one
        targetVideo.muted = true;
        targetButton.classList.remove('active');
        targetButton.textContent = 'Unmute';
      }
    }

    function setupGlobalVolumeControl() {
      const slider = document.getElementById('volumeSlider');
      const valueLabel = document.getElementById('volumeValue');
      // const audio = document.getElementById('audioPlayer');

      // Load saved volume or default to 1.0
      const savedVolume = localStorage.getItem('mosaicAudioVolume');
      const initialVolume = savedVolume !== null ? parseFloat(savedVolume) : 1.0;

      slider.value = initialVolume;
      valueLabel.textContent = Math.round(initialVolume * 100) + '%';

      // // Apply stored volume to the audio element only
      // audio.volume = initialVolume;

      // Apply stored volume to ALL videos 
      allVideos.forEach(v => v.volume = initialVolume);

      const applyVolume = (val) => {
        // audio.volume = val;
        // Apply to all videos
        allVideos.forEach(v => v.volume = val);
        
        valueLabel.textContent = Math.round(val * 100) + '%';

        // Persist the value
        localStorage.setItem('mosaicAudioVolume', val);
      };

      slider.addEventListener('input', () => {
        const val = parseFloat(slider.value);
        applyVolume(val);
      });
    }      

    async function renderGrid() {
      const cfg = await loadSettings();
      const channels = await loadChannels(cfg.tvheadend_url);

      // set fixed number of columns from config
      document.documentElement.style.setProperty('--grid-cols', cfg.grid_cols);

      const container = document.getElementById('grid');
      container.innerHTML = '';
      allVideos = [];
      allMuteButtons = [];

      for (let r = 0; r < cfg.grid_rows; r++) {
        for (let c = 0; c < cfg.grid_cols; c++) {
          const index = r * cfg.grid_cols + c;

          const cellCfg = cfg.cells.find(x => x.row === r && x.col === c);

          if (cellCfg && cellCfg.channel_uuid) {
            const ch = findChannel(channels, cellCfg.channel_uuid);
            if (ch) {
              const streamUrl = buildStreamURL(cfg.tvheadend_url, ch);
              const cell = createCell(cfg.tvheadend_url, ch, streamUrl, index);
              container.appendChild(cell);
            } else {
              const emptyCell = document.createElement('div');
              emptyCell.className = 'cell empty-cell';
              emptyCell.textContent = 'Unknown channel';
              container.appendChild(emptyCell);
            }
          } else {
            const emptyCell = document.createElement('div');
            emptyCell.className = 'cell empty-cell';
            emptyCell.textContent = 'Empty';
            container.appendChild(emptyCell);
          }
        }
      }

      setupGlobalVolumeControl();
    }

    renderGrid();

    function isMobile() {
      return /Android|iPhone|iPad|iPod|Mobi/i.test(navigator.userAgent);
    }

    function applyMobileFullscreenFix() {
      if (!isMobile()) return;

      const fsEl = document.fullscreenElement || document.webkitFullscreenElement;
      if (!fsEl) return;

      const wrapper = fsEl.querySelector('.video-wrapper');
      // const video = fsEl.querySelector('video');

      const isPortrait = window.innerHeight > window.innerWidth;

      let w;

      if (isPortrait) {
        // Portrait: use full width
        w = window.innerWidth + 'px';
      } else {
        // Landscape: subtract your 96px offset
        w = (window.innerWidth - 96) + 'px';
      }

      fsEl.style.width = w;
      if (wrapper) wrapper.style.width = w;
    }


    // optional: update on orientation / resize while in fullscreen
    window.addEventListener('resize', () => {
      if (document.fullscreenElement) {
        applyMobileFullscreenFix();
      }
    });


    function inFullscreen() {
      return document.fullscreenElement || document.webkitFullscreenElement;
    }

    function exitFs() {
      if (document.exitFullscreen) document.exitFullscreen();
      else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
    }    

    function setupTapToExitFullscreen() {
      document.addEventListener('touchend', () => {
        if (document.fullscreenElement || document.webkitFullscreenElement) {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          }
        }
      });
    }

    setupTapToExitFullscreen();

    function setupFullscreenHeaderBehavior() {
      const header = document.querySelector('header');

      document.addEventListener('fullscreenchange', () => {
        if (document.fullscreenElement) {
          header.classList.add('hidden-in-fullscreen');
        } else {
          header.classList.remove('hidden-in-fullscreen');
        }
      });

      // iOS Safari fallback
      document.addEventListener('webkitfullscreenchange', () => {
        if (document.webkitFullscreenElement) {
          header.classList.add('hidden-in-fullscreen');
        } else {
          header.classList.remove('hidden-in-fullscreen');
        }
      });
    }    

    setupFullscreenHeaderBehavior();

    function setupFullscreenHandler() {
      const onFsChange = () => {
        const fsEl = document.fullscreenElement || document.webkitFullscreenElement;

        if (fsEl) {
          // ENTERING FULLSCREEN
          applyMobileFullscreenFix();
          return;
        }

        // EXITING FULLSCREEN
        const maxed = document.querySelector('.cell.maxed');
        if (maxed) {
          maxed.style.height = '';
          maxed.style.width = '';
          const wrapper = maxed.querySelector('.video-wrapper');
          // const video = maxed.querySelector('video');
          if (wrapper) {
            wrapper.style.height = '';
            wrapper.style.width = '';
          }
          // if (video) video.style.height = '';
        }

        if (maxedCell) {
          disableMaxMode();
        }
      };

      document.addEventListener('fullscreenchange', onFsChange);
      document.addEventListener('webkitfullscreenchange', onFsChange);
    }

    document.addEventListener('DOMContentLoaded', setupFullscreenHandler);



  </script>
</body>
</html>
